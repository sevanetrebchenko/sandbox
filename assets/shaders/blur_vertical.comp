
#version 450 core

// Size of the maximum allowed blur kernel, in pixels.
#define MAX_BLUR_KERNEL_RADIUS 50
#define MAX_BLUR_KERNEL_SIZE   2 * MAX_BLUR_KERNEL_RADIUS + 1

layout (local_size_x = 1, local_size_y = 128, local_size_z = 1) in; // Declares (1 x 128 x 1) thread group size.

layout (rgba32f) uniform readonly  image2D src;
layout (rgba32f) uniform writeonly image2D dst;

layout (std140, binding = 3) uniform BlurKernel {
    float weights[MAX_BLUR_KERNEL_SIZE];
} blurKernel;

uniform int blurKernelRadius; // w

// Data that is shared with other threads in the dispatch group.
shared float v[128 + MAX_BLUR_KERNEL_SIZE];

void main() {
    ivec2 imagePosition = ivec2(gl_GlobalInvocationID.xy);
    uint threadIndex = gl_LocalInvocationID.y; // 1 x 128, only y matters.

    v[threadIndex] = imageLoad(src, imagePosition + ivec2(0, -blurKernelRadius)).r; // Reading depth information, all channels store the same.

    // First 2 w threads load an extra pixel out past the 128 thread boundary.
    if (threadIndex < 2 * blurKernelRadius) {
        v[threadIndex + 128] = imageLoad(src, imagePosition + ivec2(0, 128 - blurKernelRadius)).r;
    }

    // Force memory synchronization.
    barrier();

    // Compute blur.
    float sum = 0.0f;
    for (int i = 0; i <= 2 * blurKernelRadius; ++i) {
        sum += blurKernel.weights[i] * v[threadIndex + i];
    }

    // Store 'sum' in the output image.
    // vec4 b = vec4(sum, sum * sum, sum * sum * sum, sum * sum * sum * sum);
    imageStore(dst, imagePosition, vec4(sum, sum, sum, 1.0f));
}
